메이저 릴리즈 마다, 코드한줄을 작성하는 비용이 기하급수적으로 증가함. 그런 비용을 줄이는 여러가지 방법중에서 Java에서 다루는 객체 지향관점에서 소프트웨어를 바라본다.



## 객체

- 절차지향: 여러 프로시져(함수,메서드)가 데이터를 변경하는
- 객체지향: 객체 안에 (데이터 + 프로시저)
- 객체의 핵심 -> 기능을 제공
  - 기능 명세: 인터페이스 
  - 객체가 제공하는 기능 명세
    - 오퍼에리션 이름 
    - 파라미터
    - 결과 
  - 메세지 
    - 다른 객체에게 요청하는거



## 캡슐화 

- 객체가 내부적으로 기능을 어떻게 구현했는지 감추는것 
- 외부에 영향을 주지 않고 객체 내부의 구현을 변경하는 것 

- 캡슐화를 위한 두가지 

  - tell don't ask : 데이터를 달라하지 말고, 해달라고 하기

  - demeter's law

    - 메서드에서 생성한 객체의 메서드만 호출
    - 파라미터로 받은 객체의 메서드만 호출
    - 필드로 참조하는 객체의 메서드만 호출

    

## 추상화 ⭐️⭐️⭐️

- 추상화를 잘하는 개발자 -> 진짜 잘하는구낭 
- 데이터나 프로세스등을 의미가 비슷한 개념이나 의미있는 표현으로 정의하는 과정 
- 타입추상화
  - 여러 구현 클래스를 대표하는 상위 타입도출 
    - 흔히 인터페이스 타입으로 추상화 
    - 추상화 타입과 구현은 타입상속으로 연결 
  - 추상 타입 사용에 따른 이점: 유연함
- 추상화를 한다. -> 추상타입증가 -> 복잡도가 증가 한다. 
  - **<u>실제 변경, 확장이 발생할때 추상화를 시도</u>**
- 추상화는 OCP와 연결된다. 
- 정리 
  - 캡슐화와 추상화 
    - 개발비용을 낮추주는 객체 지향의 두가지 특징 
    - 캡슐화 
      - 기능 구현을 외부에 감춤
      - 구현 변경이 날 사용하는 외부에 영향을 주지 않음 
    - 추상화
      - 소스코드에서 의존 대상을 간접 참조
      - 사용하는 의존 대상 변경이 나에게 영향을 주지 않음
      - 연속된 if-else나 중첩된 if-else가 많다면 OCP를 고민



## 기능과 책임 분리