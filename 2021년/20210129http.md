## 인터넷 네트워크

- IP 패킷을 만들어서 던짐

  - IP 패킷: 출발지 IP, 목적지 IP, 그리고 데이터

  > Packet = Package + Bucket 의 합성어 ! 

- IP프로토콜의 한계가 존재

  - 중간에 노드를 타서, 먼저 뭐가 도착하는지 순서를 보장X 
  - 여러개의 프로그램이 실행중일때, 어떤 것을 선택하느냐의 문제 
  - 서버측의 문제가 생겨서 더이상 전달이 되지 않는 문제 
  - 그에 대한 대안으로 TCP, UDP 개념이 나옴

- TCP, UDP 

  - 인터넷 프로토콜 계층 (애플리케이션 > 전송(TCP,UDP) > IP > 네트워크 인터페이스)
    - 1) 애플리케이션: 메세지 전송 > 소켓라이브러리를 통해 전달 
    - 2) TCP: TCP정보 생성, 메세지 데이터 포함 
      - 출발지 포트, 목적지 포트, **<u>전송 제어</u>**, **<u>검증 정보</u>** ... 이런데이터들이 포함 
    - 3) IP: IP패킷 생성, TCP데이터 포함 
    - 4) Ethernet Frame: (Mac address)와 같은 물리적인 정보도 포함되어서 나감 
  - TCP (Transmission Control Protocol): 전송제어 프로토콜 
    - 연결지향 3way handshake (가상 연결). ~ 진짜 연결이 된게 아니고, 개념적인 연결인것
      - 1) SYN:접속요청 
      - 2) SYN + ACK 
      - 3) ACK : 요즘에 이부분에서 데이터도 같이 전달함
    - 데이터 전달 보증
    - 순서 보장 
  - UDP 
    - 하얀 도화지에 비유(기능이 없음)
    - 데이터 전달 보장 X 
    - 순서 보장X 
    - IP와 거의 같다.  + PORT  +체크섬 정도만 추가 
  - HTTP3에서는 3way handshaking도 줄여보자, UDP를 사용함
    - 전송계층에서 QUIC 프로토콜을(UDP) 사용, Google이 최초 init 
    - HTTP/2의 head-of-line blocking

- Port 

  - 한번에 둘이상 연결해야 하면
  - 0~65535 할당가능 (0~1023 잘알려진 포트라서 사용하지X)

- DNS

  - IP다 기억하기 어렵고, 변경되면 어떻게 할래? 
  - 전화번호부 (도메인명 - IP) 



## URI, 웹 브라우저 요청흐름

- URI 
  - URI는 로케이터(locator), 이름(name) 또는 둘 다추가로 분류될수 있다. URI는 URL,URN을 포함한다. 
    - URL(Resource Locator)
    - URN(Reosurce Name): 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음. 
    - 결국 앞으로 URI , URL 같은 의미로 이야기함 ! 
  - path 
    - 자원에 접근에 대한 개념. 계층적으로 설계 가능
  - query
    - query paramter, query string 숫자를 넣어서 문자로 넘어가기 때문에 
  - fragment 
    - HTML내부에서 북마크정도 
- 요청흐름
  - google.com 사이트를 호출
  - DNS 조회 >> IP,PORT 정보를 찾음 
  - HTTP 요청 메세지를 생성
    - 메서드, path~query, http version 정보, host 정보들
  - 애플리케이션 계층: 
    - http 메세지 생성
    - 소켓라이브러리에 전달 : TCP/IP 연결 (IP, Port) , 데이터 전달
  - 전송계층(TCP)
    - TCP/IP패킷 생성, Http메세지 포함
  - 인터넷네트워크~ 랜카드를 통해서 밖으로 나감 
  - 수많은 노드를 거쳐서, 구글 서버에 도착 
  - 요청 패킷 도착 TCP/IP 패킷은 버리고 -> HTTP 메세지만 끄집어 내서,해석함 
  - 구글서버에서 응답 메세지를 만들어서 
    - content-type: 응답하는 데이터의 type 
    - content-length: 실제 데이터의 길이 
  - 위의 TCP/IP 패킷을 만들어서 다시 보냄
  - 웹브라우저가 렌더링해서 -> 우리가 해당 화면을 본다



## HTTP 기본 

- HTTP 메세지에 모든것을 전송 
  - HTML, TEXT
  - IMAGE, 음성, 영상, 파일
  - JSON, XML(API)
- TCP: HTTP/1.1, HTTP/2
- UDP: HTTP/3

- 특징 

  - 클라이언트 서버 구조
    - request, response 구조

  - 무상태 프로토콜
    - 서버가 클라이언트 상태를 보존X 
    - 장점: 서버를 무한히 확장 가능하다. (scale out)
    - 단점: 전송되는 데이터양이 많아짐
  - 비연결성
    - http는 기본이 연결을 유지 하지 않는 모델 
    - 1시간동안 수천명이 서비스를 사용해도 실제 서버에서 동시 처리하는 요청은 수십개 이하로 매우 작음
    - 서버 자원을 매우 효율적으로 사용 가능
    - 한계와 극복 
      - TCP/IP 3way handshake 시간 추가 
      - HTML 뿐만 아니라 자바스크립트, CSS 수많은 자이 함께 다운로드 
      - 지금은 HTTP 지속연결(Persistent Connections)로 문제 해결 
      - HTTP/2, HTTP/3 에서 더 많은 최적화
      - 서버개발자들이 어려워하는 업무
        - 같은시간에 딱 맞추어 발생하는 대용량 트래픽
          - 1) 선착순 이벤트, 명절 KTX 예약, 학과 수업등록 
  - HTTP 메세지
    - 시작라인 (request line(요청할때) / status line(응답할때))
    - header
    - 공백
    - body
  - 단순함, 확장 가능 
    - HTTP 는 단순하다. 메세지도 매우 단순



## HTTP 메서드 

- POST: 요청 데이터를 처리, 새로운 엔티티를 만듬. 주로 등록에 쓰임
- PUT: 리소스를 대체, 해당 리소스가 없으면 생성
- PATCH: 리소스를 부분 변경 
- HEAD: GET과 동일, 메세지body를 제외하고 상태줄 헤더만 반환 
- OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)를 설명(주로 CORS)에서 사용



POST 

- 1) 새리소스 등록 
- 2) 요청데이터 처리
  - 단순히 데이터 생성하거나, 변경하는것을 넘어서 프로세스를 처리해야 하는 경우 
  - ex) POST /orders/{orderId}/start-delivery (**<u>컨트롤 URI</u>**)
- 3) 다른 메서드로 처리하기 애매한 경우
  - JSON으로 조회 데이터를 넘겨야 하는데, GET메서드를 사용하기 어려운 경우
    - GET 메서드는 Body로 사용할수 있지만, 지원하지 않는 서버들도 있다.



PUT 

- 주의: 리소스를 완전히 대체한다. -> 리소스 부분 변경인건 PATCH로 보낸다. (지원 안되는 서버도 있음)



HTTP 메서드 속성 

- 안전: 호출해도 리소스를 변경하지 않는다.  GET같은경우(멱등성을 보장)
- 멱등: 계속 호출해도 같은 결과를 리턴하면
  - 멱등 메서드 
    - GET
    - PUT(새로 덮어씌우니까)
    - DELETE(2번,3번 지워도 결국 지워진거니까)
  - 활용 (어디에 사용하나? )
    - 자동 복구 메커니즘 (똑같은 일을 두번 할수 있다. TimeOut 등 -> Retry)
  - Q&A 
    - 다른 사용자(스레드)에서 해당 바뀐 데이터를 조회해서 바뀐 리소스라면? 
      - A: 그런것 고려하지 않는다. 
- 캐시가능(Cacheable)
  - 실제로는 GET, HEAD 정도만 캐시로 사용
  - POST,PATCH도 가능하나, 본문 내용까지 캐시 키로 고려애햐 하는데, 구현이 쉽지 않음



## HTTP 메서드 활용

- 정적데이터: 그냥요청 
- 동적데이터: 쿼리 파라미터 사용
- HTML form 데이터 전송
  - x-www-form-urlencoded: key&value 형태로 encoding해서 body로 넘겨서 요청함
  - multipart/form-data : 바이너리 데이터를 전송하는 경우, boundary로 짤라서 요청함
  - 참고: HTML form 전송은 GET, POST 만 지원



HTTP 설계 예시 

> https://restfulapi.net/resource-naming/

- 문서 
  - 단일 개념(파일하나, 객체 인스턴스, 데이터베이스 ROW)
  - 예 ) /members/100, /files/star.jpg

- HTTP API 컬렉션 
  - 서버가 관리하는 리소스 디렉토리
  - 서버가 리소스의 URI를 생성하고 관리
  - 예) POST /members
- HTTP API 스토어
  - 클라이언트가 관리하는 자원 저장소 
  - 클라이언트가 리소스의 URI를 알고 관리 
  - 예) PUT /files/{filename}
- 컨트롤러 컨트롤 API 
  - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행 
  - 동사를 직접 사용 
  - 예) POST /members/{id}/delete  



## HTTP 상태 코드 

- 2XX 성공

  - 201: CREATED 
  - 202: Accepted 
    - 요청이 접수는 되었으나 처리가 되지 않음 -> 배치에서 사용
  - 204: No Content
    - 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음 
    - 예 )웹문서 편집기 save버튼

- 3XX 리다이렉션 

  - 기존의 이벤트 페이지 -> 새로운 이벤트 페이지로 변한경우 

  - 예전 이벤트 페이지 /event 로 요청보내면 

    - -> 301 moved permanetly를 받고, Location 헤더에 : /new-event 가 있으면 
    - -> 브라우저가 자동으로 /new-event 페이지로 요청을 보냄(리다이렉션)

  - 리다이렉션 종류

    - 영구 리다이렉션: 특정 리소스의 URI가 영구적으로 이동
      - /event -> /new-event
    - 일시 리다이렉션: 일시적 변경
      - 주문완료후 주문 내역화면으로 이동
      - PRG: Post/Redirect/Get
    - 특수 리다이렉션
      - 결과 대신 캐시를 사용

  - 영구 리다이렉션 301,308

    - 검색엔진등에서도 변경 인지
    - 301 
      - 리다이렉트 요청 메서드가 GET으로 변하고, POST 본문이 없어질수 있음
    - 308 
      - 301과 기능은 같음
      - 리다이렉트 요청 메서드와 본문 유지( 처음 POST 본문이 사라지지 않음 )
      - 실무에서 이렇게 까지 사용하지 않는다, 새로운 이벤트면 그냥 새롭게 데이터를 입력받게 하는게 맞다! 

  - 일시적 리다이렉션 302,307,303⭐️⭐️⭐️⭐️⭐️ (실무에 많이)

    - 리소스의 URI 가 일시적으로 변경 

    - 따라서 검색엔진등에서 URL을 변경하면 안됨

    - 302 Found

      - 리다이렉트 요청시, GET으로 변하고, 본문이 제거될수 있음(MAY)

    - 307 Temporary Redirect 

      - 302와 기능 같음 
      - 리다이렉트시 요청메서드와 본문 유지(요청 메서드를 변경하면 안된다.)

    - 303 See Other

      - 302와 기능은 같음
      - 리다이렉트시 요청 메서드가 GET으로 변경

    - PRG: Post/Redirect/Get

      - 일시적인 리다이렉션 -예시 
      - POST 주문후에 새로고침으로 인한 중복 주문 방지 
      - POST로 주문후에 주문결과 화면을 GET메서드로 리다이렉트
      - 새로고침해도 결과화면을 GET으로 조회
      - 중복주문대신에 결과화면만 GET으로 다시 요청

      > 1. POST /order 
      > 2. 응답: 302 Found / Location:/order-result/19
      > 3. 브라우저는 자동리다이렉트 
      > 4. GET 요청 /order-result/19 
      > 5. 응답: OK
      > 6. 4번을 반복해도 결과값만 조회함