메이저 릴리즈 마다, 코드한줄을 작성하는 비용이 기하급수적으로 증가함. 그런 비용을 줄이는 여러가지 방법중에서 Java에서 다루는 객체 지향관점에서 소프트웨어를 바라본다.



## 객체

- 절차지향: 여러 프로시져(함수,메서드)가 데이터를 변경하는
- 객체지향: 객체 안에 (데이터 + 프로시저)
- 객체의 핵심 -> 기능을 제공
  - 기능 명세: 인터페이스 
  - 객체가 제공하는 기능 명세
    - 오퍼레이션 이름 
    - 파라미터
    - 결과 
  - 메세지 
    - 다른 객체에게 요청하는거



## 캡슐화 

- 객체가 내부적으로 기능을 어떻게 구현했는지 감추는것 
- 외부에 영향을 주지 않고 객체 내부의 구현을 변경하는 것 

- 캡슐화를 위한 두가지 

  - tell don't ask : 데이터를 달라하지 말고, 해달라고 하기

  - demeter's law

    - 메서드에서 생성한 객체의 메서드만 호출
    - 파라미터로 받은 객체의 메서드만 호출
    - 필드로 참조하는 객체의 메서드만 호출

    

## 추상화 ⭐️⭐️⭐️

- 추상화를 잘하는 개발자 -> 진짜 잘하는구낭 
- 데이터나 프로세스등을 의미가 비슷한 개념이나 의미있는 표현으로 정의하는 과정 
- 타입추상화
  - 여러 구현 클래스를 대표하는 상위 타입도출 
    - 흔히 인터페이스 타입으로 추상화 
    - 추상화 타입과 구현은 타입상속으로 연결 
  - 추상 타입 사용에 따른 이점: 유연함
- 추상화를 한다. -> 추상타입증가 -> 복잡도가 증가 한다. 
  - **<u>실제 변경, 확장이 발생할때 추상화를 시도</u>**
- 추상화는 OCP와 연결된다. 
- 정리 
  - 캡슐화와 추상화 
    - 개발비용을 낮추주는 객체 지향의 두가지 특징 
    - 캡슐화 
      - 기능 구현을 외부에 감춤
      - 구현 변경이 날 사용하는 외부에 영향을 주지 않음 
    - 추상화
      - 소스코드에서 의존 대상을 간접 참조
      - 사용하는 의존 대상 변경이 나에게 영향을 주지 않음
      - 연속된 if-else나 중첩된 if-else가 많다면 OCP를 고민



## 기능과 책임 분리

- 기능 분해
  - 기능은 하위 기능으로 분해 (mindMap 으로 해도 괜찮을듯!✅)
- 기능은 곧 책임 
  - 분리한 각 기능을 알맞게 분배
- 큰 클래스, 큰메서드
  - 클래스나 메서드가 커지면 
    - 큰 클래스 -> 많은 필드를 많은 메서드가 공유
    - 큰 메서드 -> 많은 변수를 많은 코드가 공유
    - 여러기능이 한 클래스/메서드에 섞여 있을 가능성 
  - 절차지향의 문제 발생
  - 책임에 따라 알맞게 코드 분리 필요

- 몇가지 책임 분배/분리 방법
  - 패턴적용
    - 간단한웹 MVC 
    - 도메인주도 설계 
    - AOP 
    - GoF 
  - 계산기능분리
  - 외부연동분리
    - ex) RestTemplate 내부 API 호출하는
  - 조건별 분기는 추상화
    - 연속적인 if-else는 추상화 고민
- 알맞은 책임분리와 테스트 
  - 책임분리를 잘하면 부분 테스트가 용이
    - 거꾸로 말하면 테스트가능한 코드를만들수록 책임 분리가 잘 될 가능성이 높아짐 (TDD)

## 의존

> 코드에서 의존을 잘관리하는 사람 👍

- 기능 구현을 위해 다른 구성 요소를 사용하는 것 
  - 예) 객세 생성, 메서드 호출, 데이터 사용 
- 결합도
  - 구성요소가 서로 의존하는 정도 
- 의존은 변경이 전파될 가능성을 의미 
  - 의존하는 대상이 바뀌면 바뀔 가능성이 높아짐
  - 의존대상은 적을수록 변경에 덜 영향
- 의존대상 많을때 1, 기능많은 경우 
  - 기능별로 알맞게 분리 
- 의존대상 많을때 2, 묶어보기
  - 몇가지 의존 대상을 단일 기능으로 묶어서 생각해보면 의존 대상을 줄일 수 있음 
- 의존 대상 객체를 직접 생성하면? 
  - 생성클래스가 바뀌면 의존하는 코드도 바뀜 
  - 의존대상 객체를 직접 생성하지 않는 방법
    - 의존 주입
    - 서비스 로케이터 ✅
    - 팩토리 

## DIP 

- 고수준 모듈: 의미있는 단일 기능을 제공
  - 상위 수준의 정책 구현
- 저수준 모듈: 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현



## 정리 

- 객체지향
  - 객체 :기능제공
  - 캡슐화 추상화로 변화에 유연하게 함 
  - OCP: 확장에 유연한 구조 
  - 객체의 책임은 크지 않게 
  - 기능 분해의 두 방향: 역할 분리, 추상화
  - 의존처리: DI 
  - DIP: 상위 수준에서 기능 생각하기 
    - 유연한 아키텍쳐 
  - 정리하면
    - 기능을 알맞은 크기로 잘 나누고 조합하기 
    - 캡슐화와 적절한 추상화로 유연하게 만들기